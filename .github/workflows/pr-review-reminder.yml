name: PR Review Reminder and Escalation

on:
  schedule:
    - cron: '*/15 * * * *'

  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run â€” only log, do not send Slack messages'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  check-pending-reviews:
    name: Check Pending PR Reviews
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Find Pending PRs
        id: pending-prs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { loadConfig, getSlackMention, getReviewerMentions } = require('./.github/scripts/helpers/config');
            const { getPRFileDetails, getPRReviewStatus, formatTimeElapsed, calculateSeverity } = require('./.github/scripts/helpers/pr-utils');
            const { generateReminderMessage, generateStalledMessage } = require('./.github/scripts/helpers/messages');

            const config = loadConfig();
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const minApprovals = (config.review_settings && config.review_settings.min_approvals) || 2;
            const stalledThreshold = (config.review_settings && config.review_settings.stalled_threshold_minutes) || 120;

            console.log(`Config: min_approvals=${minApprovals}, stalled_threshold=${stalledThreshold} min`);

            const { data: pullRequests } = await github.rest.pulls.list({
              owner, repo, state: 'open', sort: 'created', direction: 'asc'
            });

            console.log(`Found ${pullRequests.length} open PRs`);
            const pendingPRs = [];

            for (const pr of pullRequests) {
              console.log(`\n========================================`);
              console.log(`Checking PR #${pr.number}: ${pr.title}`);

              // Skip drafts
              if (pr.draft) { console.log('  Skipping: draft'); continue; }

              // Skip opt-out labels
              const skipLabels = ['no-reminder', 'wip', 'on-hold'];
              if (pr.labels.some(l => skipLabels.includes(l.name))) {
                console.log('  Skipping: opt-out label');
                continue;
              }

              // â”€â”€ Analyze review status â”€â”€
              const reviewStatus = await getPRReviewStatus(github, owner, repo, pr, minApprovals);

              console.log(`  Status: ${reviewStatus.status}`);
              console.log(`  Reason: ${reviewStatus.reason}`);
              console.log(`  Approvals: ${reviewStatus.approvalCount}/${minApprovals}`);
              console.log(`  Approved by: ${reviewStatus.approvedBy.join(', ') || 'none'}`);
              console.log(`  Changes requested by: ${reviewStatus.changesRequestedBy.join(', ') || 'none'}`);
              console.log(`  Comments: ${reviewStatus.commentCount}, Inline: ${reviewStatus.inlineCommentCount}`);
              console.log(`  Pending reviewers: ${reviewStatus.pendingReviewers.join(', ') || 'none'}`);

              // â”€â”€ Decision logic â”€â”€
              const createdAt = new Date(pr.created_at);
              const minutesElapsed = (new Date() - createdAt) / (1000 * 60);
              const hoursElapsed = minutesElapsed / 60;
              const timeString = formatTimeElapsed(minutesElapsed);
              const createdFormatted = createdAt.toUTCString();
              const severity = calculateSeverity(minutesElapsed, config.escalation_thresholds);

              console.log(`  Elapsed: ${Math.round(minutesElapsed)} min (${Math.round(hoursElapsed * 10) / 10}h)`);
              console.log(`  Severity: ${severity}`);

              let shouldNotify = false;
              let statusMessage = '';

              if (reviewStatus.status === 'fully_approved') {
                // â”€â”€ FULLY APPROVED: Skip â”€â”€
                console.log(`  âœ… SKIP: Fully approved (${reviewStatus.approvalCount}/${minApprovals})`);
                continue;

              } else if (reviewStatus.status === 'ignored') {
                // â”€â”€ IGNORED: Always notify (existing behavior) â”€â”€
                shouldNotify = true;
                console.log(`  ðŸ”” NOTIFY: PR completely ignored`);

                const fileInfo = await getPRFileDetails(github, owner, repo, pr.number);

                statusMessage = generateReminderMessage({
                  pr, config,
                  files: fileInfo.files,
                  additions: fileInfo.additions,
                  deletions: fileInfo.deletions,
                  size: fileInfo.size,
                  timeString, createdFormatted, severity
                });

              } else if (reviewStatus.status === 'stalled') {
                // â”€â”€ STALLED: Notify only if exceeds stalled threshold â”€â”€
                if (minutesElapsed >= stalledThreshold) {
                  shouldNotify = true;
                  console.log(`  ðŸ”” NOTIFY: PR stalled (${Math.round(minutesElapsed)} min > ${stalledThreshold} min threshold)`);

                  const fileInfo = await getPRFileDetails(github, owner, repo, pr.number);

                  statusMessage = generateStalledMessage({
                    pr, config,
                    files: fileInfo.files,
                    additions: fileInfo.additions,
                    deletions: fileInfo.deletions,
                    size: fileInfo.size,
                    timeString, createdFormatted,
                    reviewStatus, minApprovals
                  });
                } else {
                  console.log(`  â³ SKIP: PR has activity but only ${Math.round(minutesElapsed)} min old (threshold: ${stalledThreshold} min)`);
                  continue;
                }
              }

              if (!shouldNotify) continue;

              console.log('  Message: ' + statusMessage.substring(0, 120) + '...');

              // â”€â”€ Gather file info (if not already loaded) â”€â”€
              let fileInfo;
              try {
                fileInfo = await getPRFileDetails(github, owner, repo, pr.number);
              } catch (e) {
                fileInfo = { files: [], additions: 0, deletions: 0, size: 'Unknown', fileNames: '', fileDescriptions: [] };
              }

              // Approved by mentions
              const approvedByMentions = reviewStatus.approvedBy
                .map(u => getSlackMention(config, u))
                .join(', ');

              pendingPRs.push({
                number: pr.number,
                title: pr.title,
                url: pr.html_url,
                author: pr.user.login,
                author_mention: getSlackMention(config, pr.user.login),
                reviewer_mentions: getReviewerMentions(config, pr.requested_reviewers),
                branch_from: pr.head.ref,
                branch_to: pr.base.ref,
                minutes_elapsed: Math.round(minutesElapsed),
                hours_elapsed: Math.round(hoursElapsed * 10) / 10,
                time_string: timeString,
                created_at: createdFormatted,
                severity,
                severity_label: severity.toUpperCase(),
                size: fileInfo.size,
                status_message: statusMessage,
                additions: fileInfo.additions,
                deletions: fileInfo.deletions,
                changed_files: fileInfo.files.length,
                file_names: fileInfo.fileNames,
                // New fields
                review_status: reviewStatus.status,
                approval_count: reviewStatus.approvalCount,
                approvals_needed: reviewStatus.approvalsNeeded,
                min_approvals: minApprovals,
                approved_by: approvedByMentions
              });
            }

            console.log(`\n========================================`);
            console.log(`Total PRs needing attention: ${pendingPRs.length}`);
            console.log(`  Ignored: ${pendingPRs.filter(p => p.review_status === 'ignored').length}`);
            console.log(`  Stalled: ${pendingPRs.filter(p => p.review_status === 'stalled').length}`);

            core.setOutput('pending_prs', JSON.stringify(pendingPRs));
            core.setOutput('should_notify', (pendingPRs.length > 0).toString());

      - name: Send Reminder to Slack
        if: steps.pending-prs.outputs.should_notify == 'true'
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
        with:
          script: |
            const { sendToSlack, buildReminderPayload } = require('./.github/scripts/helpers/slack');

            const pendingPRs = JSON.parse(`${{ steps.pending-prs.outputs.pending_prs }}`);
            const payload = buildReminderPayload(pendingPRs);

            if (process.env.DRY_RUN === 'true') {
              console.log('DRY RUN â€” Preview:');
              console.log(JSON.stringify(payload, null, 2));
              return;
            }

            const result = await sendToSlack(process.env.SLACK_WEBHOOK_URL, payload);
            console.log('Slack response:', result);

      - name: Update PR Labels
        if: steps.pending-prs.outputs.should_notify == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { updateSeverityLabel } = require('./.github/scripts/helpers/labels');

            const pendingPRs = JSON.parse(`${{ steps.pending-prs.outputs.pending_prs }}`);

            for (const pr of pendingPRs) {
              await updateSeverityLabel(
                github, context.repo.owner, context.repo.repo,
                pr.number, pr.severity
              );
            }