name: PR Review Completed

on:
  pull_request_review:
    types: [submitted, dismissed]

  pull_request:
    types: [closed]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  handle-review:
    name: Handle Review Submission
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_review'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Process Review and Notify
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { loadConfig, getSlackMention } = require('./.github/scripts/helpers/config');
            const { sendToSlack, buildApprovedPayload, buildPartialApprovalPayload, buildChangesRequestedPayload } = require('./.github/scripts/helpers/slack');
            const { cleanupAllLabels } = require('./.github/scripts/helpers/labels');

            const config = loadConfig();
            const pr = context.payload.pull_request;
            const review = context.payload.review;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Analyze reviews
            const { data: allReviews } = await github.rest.pulls.listReviews({
              owner, repo, pull_number: pr.number
            });

            const latestReviews = {};
            for (const r of allReviews) {
              if (!latestReviews[r.user.login] ||
                  new Date(r.submitted_at) > new Date(latestReviews[r.user.login].submitted_at)) {
                latestReviews[r.user.login] = r;
              }
            }

            const approvals = Object.entries(latestReviews)
              .filter(([_, r]) => r.state === 'APPROVED')
              .map(([user]) => user);

            const changesRequested = Object.entries(latestReviews)
              .filter(([_, r]) => r.state === 'CHANGES_REQUESTED')
              .map(([user]) => user);

            const stillPending = pr.requested_reviewers
              .filter(r => !latestReviews[r.login])
              .map(r => r.login);

            const isFullyApproved =
              stillPending.length === 0 &&
              changesRequested.length === 0 &&
              approvals.length > 0;

            const reviewTime = Math.round(
              (new Date(review.submitted_at) - new Date(pr.created_at)) / (1000 * 60)
            ) + ' minutes';

            const mention = (u) => getSlackMention(config, u);

            console.log(`Review: ${review.state} by ${review.user.login}`);
            console.log(`Fully approved: ${isFullyApproved}`);

            // Send appropriate notification
            let payload;

            if (isFullyApproved) {
              payload = buildApprovedPayload(
                pr,
                mention(pr.user.login),
                approvals.map(a => mention(a)).join(', '),
                reviewTime
              );

              await cleanupAllLabels(github, owner, repo, pr.number);
              await github.rest.issues.addLabels({
                owner, repo, issue_number: pr.number, labels: ['approved']
              });

            } else if (review.state === 'approved') {
              payload = buildPartialApprovalPayload(
                pr,
                mention(review.user.login),
                reviewTime,
                stillPending.map(p => mention(p)).join(', ') || 'None',
                approvals.length.toString(),
                stillPending.length.toString()
              );

            } else if (review.state === 'changes_requested') {
              payload = buildChangesRequestedPayload(
                pr,
                mention(review.user.login),
                mention(pr.user.login),
                (review.body || 'No comment').substring(0, 300)
              );
            }

            if (payload) {
              const result = await sendToSlack(process.env.SLACK_WEBHOOK_URL, payload);
              console.log('Slack response:', result);
            }

  handle-closed:
    name: Handle PR Closed or Merged
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Notify and Cleanup
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { sendToSlack, buildMergedPayload, buildClosedPayload } = require('./.github/scripts/helpers/slack');
            const { cleanupAllLabels } = require('./.github/scripts/helpers/labels');

            const pr = context.payload.pull_request;

            const payload = pr.merged
              ? buildMergedPayload(pr)
              : buildClosedPayload(pr);

            const result = await sendToSlack(process.env.SLACK_WEBHOOK_URL, payload);
            console.log('Slack response:', result);

            await cleanupAllLabels(
              github, context.repo.owner, context.repo.repo,
              pr.number, ['changes-requested']
            );