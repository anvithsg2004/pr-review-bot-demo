name: PR Review Notification

on:
  pull_request:
    types: [opened, reopened, review_requested, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: pr-notify-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  notify-slack:
    name: Send Slack Notification
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Gather PR Information
        id: pr-info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const config = JSON.parse(
              fs.readFileSync('.github/config/team-config.json', 'utf8')
            );

            const pr = context.payload.pull_request;

            const authorConfig = config.team_members[pr.user.login];
            const authorMention = authorConfig
              ? `<@${authorConfig.slack_id}>`
              : pr.user.login;

            const reviewerMentions = pr.requested_reviewers.map(r => {
              const member = config.team_members[r.login];
              return member ? `<@${member.slack_id}>` : `@${r.login}`;
            }).join(' ') || 'None assigned';

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const additions = files.reduce((sum, f) => sum + f.additions, 0);
            const deletions = files.reduce((sum, f) => sum + f.deletions, 0);
            const totalChanges = additions + deletions;

            let size = 'Small';
            if (totalChanges > 500) size = 'Large';
            else if (totalChanges > 200) size = 'Medium';

            const fileNames = files.map(f => f.filename).join(', ');

            const rawBody = (pr.body || 'No description provided').substring(0, 300);
            const cleanBody = rawBody
              .replace(/`/g, '')
              .replace(/\n/g, ' ')
              .replace(/\r/g, '')
              .replace(/"/g, "'")
              .replace(/#/g, '')
              .replace(/\*/g, '')
              .replace(/\|/g, '-')
              .trim();

            core.setOutput('pr_number', pr.number);
            core.setOutput('title', pr.title);
            core.setOutput('url', pr.html_url);
            core.setOutput('author', pr.user.login);
            core.setOutput('author_mention', authorMention);
            core.setOutput('reviewer_mentions', reviewerMentions);
            core.setOutput('branch', pr.head.ref);
            core.setOutput('base', pr.base.ref);
            core.setOutput('files_changed', files.length);
            core.setOutput('additions', additions);
            core.setOutput('deletions', deletions);
            core.setOutput('size', size);
            core.setOutput('file_names', fileNames);
            core.setOutput('body', cleanBody);

      - name: Generate AI Message
        id: ai-message
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_TITLE: ${{ steps.pr-info.outputs.title }}
          PR_AUTHOR: ${{ steps.pr-info.outputs.author }}
          PR_BRANCH: ${{ steps.pr-info.outputs.branch }}
          PR_BASE: ${{ steps.pr-info.outputs.base }}
          PR_SIZE: ${{ steps.pr-info.outputs.size }}
          PR_ADDITIONS: ${{ steps.pr-info.outputs.additions }}
          PR_DELETIONS: ${{ steps.pr-info.outputs.deletions }}
          PR_FILES_CHANGED: ${{ steps.pr-info.outputs.files_changed }}
          PR_FILE_NAMES: ${{ steps.pr-info.outputs.file_names }}
          PR_BODY: ${{ steps.pr-info.outputs.body }}
        with:
          script: |
            const https = require('https');

            async function callGemini(prompt) {
              const apiKey = process.env.GEMINI_API_KEY;
              if (!apiKey) {
                console.log('No Gemini API key found');
                return null;
              }

              const url = `/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

              const requestBody = JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                  temperature: 0.7,
                  maxOutputTokens: 300,
                  topP: 0.9
                }
              });

              return new Promise((resolve) => {
                const req = https.request({
                  hostname: 'generativelanguage.googleapis.com',
                  path: url,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  }
                }, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const parsed = JSON.parse(data);

                      if (parsed.error) {
                        console.log('Gemini API error:', parsed.error.message);
                        resolve(null);
                        return;
                      }

                      if (parsed.candidates &&
                          parsed.candidates[0] &&
                          parsed.candidates[0].content &&
                          parsed.candidates[0].content.parts &&
                          parsed.candidates[0].content.parts[0]) {
                        const text = parsed.candidates[0].content.parts[0].text;
                        resolve(text.trim());
                      } else {
                        console.log('Unexpected Gemini response:', JSON.stringify(parsed).substring(0, 500));
                        resolve(null);
                      }
                    } catch (e) {
                      console.log('Parse error:', e.message);
                      console.log('Raw response:', data.substring(0, 500));
                      resolve(null);
                    }
                  });
                });
                req.on('error', (e) => {
                  console.log('Request error:', e.message);
                  resolve(null);
                });
                req.write(requestBody);
                req.end();
              });
            }

            const prompt = [
              'You are a Slack notification bot for a software development team.',
              'Write exactly 2 to 3 sentences to inform the team that a new pull request has been created and needs their review.',
              '',
              'Here are the pull request details:',
              'Title: ' + process.env.PR_TITLE,
              'Author: ' + process.env.PR_AUTHOR,
              'Branch: ' + process.env.PR_BRANCH + ' merging into ' + process.env.PR_BASE,
              'Size of change: ' + process.env.PR_SIZE + ' with ' + process.env.PR_ADDITIONS + ' lines added and ' + process.env.PR_DELETIONS + ' lines deleted',
              'Number of files changed: ' + process.env.PR_FILES_CHANGED,
              'File names: ' + process.env.PR_FILE_NAMES,
              'Description from the author: ' + (process.env.PR_BODY || 'No description provided'),
              '',
              'Your message must follow these rules strictly:',
              '1. Write exactly 2 to 3 complete sentences',
              '2. Briefly describe what the PR changes based on the title and file names',
              '3. Estimate how long the review might take based on the size',
              '4. Ask the team to review it',
              '5. Use a friendly and professional tone',
              '6. Do NOT use any emojis',
              '7. Do NOT include any links or URLs',
              '8. Do NOT use any markdown formatting such as asterisks, underscores, backticks, or hash symbols',
              '9. Write in plain English text only',
              '10. Your response should contain ONLY the message text, nothing else'
            ].join('\n');

            console.log('Sending prompt to Gemini...');

            const aiMessage = await callGemini(prompt);

            let finalMessage = '';

            if (aiMessage) {
              let cleaned = aiMessage
                .replace(/\*/g, '')
                .replace(/`/g, '')
                .replace(/_/g, ' ')
                .replace(/~/g, '')
                .replace(/#/g, '')
                .replace(/\n+/g, ' ')
                .replace(/\s+/g, ' ')
                .replace(/"/g, "'")
                .trim();

              console.log('Raw AI response:', aiMessage);
              console.log('Cleaned AI response:', cleaned);
              console.log('Cleaned length:', cleaned.length);

              if (cleaned.length >= 50) {
                finalMessage = cleaned;
                console.log('Using AI message');
              } else {
                console.log('AI message too short, using fallback');
              }
            } else {
              console.log('AI returned null, using fallback');
            }

            if (!finalMessage) {
              finalMessage = 'A new pull request titled ' + process.env.PR_TITLE +
                ' has been opened and is ready for review. It is a ' +
                process.env.PR_SIZE.toLowerCase() + ' change touching ' +
                process.env.PR_FILES_CHANGED + ' file(s). Please take a look when you have a moment.';
              console.log('Using fallback:', finalMessage);
            }

            core.setOutput('message', finalMessage);

      - name: Send Slack Notification
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Pull Request — Review Requested",
                    "emoji": false
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*<${{ steps.pr-info.outputs.url }}|#${{ steps.pr-info.outputs.pr_number }}: ${{ steps.pr-info.outputs.title }}>*"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "plain_text",
                    "text": ${{ toJSON(steps.ai-message.outputs.message) }},
                    "emoji": false
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Author:*\n${{ steps.pr-info.outputs.author_mention }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Reviewers:*\n${{ steps.pr-info.outputs.reviewer_mentions }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n`${{ steps.pr-info.outputs.branch }}` into `${{ steps.pr-info.outputs.base }}`"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Size:*\n${{ steps.pr-info.outputs.size }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Files Changed:*\n${{ steps.pr-info.outputs.files_changed }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Lines Changed:*\n+${{ steps.pr-info.outputs.additions }} / -${{ steps.pr-info.outputs.deletions }}"
                    }
                  ]
                },
                {
                  "type": "divider"
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "Severity: *LOW* | Reminders will follow if review remains pending"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "Review PR",
                        "emoji": false
                      },
                      "url": "${{ steps.pr-info.outputs.url }}/files",
                      "style": "primary"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Discussion",
                        "emoji": false
                      },
                      "url": "${{ steps.pr-info.outputs.url }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `**Slack Notification Sent**\n\n` +
                    `A review request has been posted to Slack.\n\n` +
                    `**Escalation Timeline (Demo Mode):**\n` +
                    `- 0–15 min: Channel notification (LOW)\n` +
                    `- 15–30 min: MEDIUM severity\n` +
                    `- 30–45 min: HIGH severity\n` +
                    `- 45+ min: CRITICAL severity\n`
            });