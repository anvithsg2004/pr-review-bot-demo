name: PR Review Notification

on:
  pull_request:
    types: [opened, reopened, review_requested, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: pr-notify-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  notify-slack:
    name: Send Slack Notification
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Gather PR Information
        id: pr-info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const config = JSON.parse(
              fs.readFileSync('.github/config/team-config.json', 'utf8')
            );

            const pr = context.payload.pull_request;

            const reviewers = pr.requested_reviewers
              .map(r => r.login).join(', ') || 'None assigned';

            const authorConfig = config.team_members[pr.user.login];
            const authorMention = authorConfig
              ? `<@${authorConfig.slack_id}>`
              : pr.user.login;

            const reviewerMentions = pr.requested_reviewers.map(r => {
              const member = config.team_members[r.login];
              return member ? `<@${member.slack_id}>` : `@${r.login}`;
            }).join(' ') || 'None assigned';

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const additions = files.reduce((sum, f) => sum + f.additions, 0);
            const deletions = files.reduce((sum, f) => sum + f.deletions, 0);
            const totalChanges = additions + deletions;

            let size = 'Small';
            if (totalChanges > 500) size = 'Large';
            else if (totalChanges > 200) size = 'Medium';

            // Get file names for AI context
            const fileNames = files.map(f => f.filename).join(', ');

            core.setOutput('pr_number', pr.number);
            core.setOutput('title', pr.title);
            core.setOutput('url', pr.html_url);
            core.setOutput('author', pr.user.login);
            core.setOutput('author_mention', authorMention);
            core.setOutput('reviewer_mentions', reviewerMentions);
            core.setOutput('branch', pr.head.ref);
            core.setOutput('base', pr.base.ref);
            core.setOutput('files_changed', files.length);
            core.setOutput('additions', additions);
            core.setOutput('deletions', deletions);
            core.setOutput('size', size);
            core.setOutput('file_names', fileNames);
            core.setOutput('body', (pr.body || 'No description').substring(0, 300));

      - name: Generate AI Message
        id: ai-message
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        with:
          script: |
            const https = require('https');

            // ========================================
            // CALL GEMINI API
            // ========================================
            async function callGemini(prompt) {
              const apiKey = process.env.GEMINI_API_KEY;
              const url = `/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

              const requestBody = JSON.stringify({
                contents: [{
                  parts: [{
                    text: prompt
                  }]
                }],
                generationConfig: {
                  temperature: 0.7,
                  maxOutputTokens: 200
                }
              });

              return new Promise((resolve, reject) => {
                const req = https.request({
                  hostname: 'generativelanguage.googleapis.com',
                  path: url,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  }
                }, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const parsed = JSON.parse(data);
                      if (parsed.candidates && parsed.candidates[0]) {
                        const text = parsed.candidates[0].content.parts[0].text;
                        resolve(text.trim());
                      } else {
                        console.log('Gemini response:', data);
                        resolve(null);
                      }
                    } catch (e) {
                      console.log('Parse error:', e.message);
                      resolve(null);
                    }
                  });
                });
                req.on('error', (e) => {
                  console.log('Request error:', e.message);
                  resolve(null);
                });
                req.write(requestBody);
                req.end();
              });
            }

            // ========================================
            // BUILD PROMPT
            // ========================================
            const prompt = `You are a helpful Slack bot for a software engineering team. Generate a short, professional message (2-3 sentences) to notify the team about a new pull request that needs review.

            PR Details:
            - Title: "${{ steps.pr-info.outputs.title }}"
            - Author: ${{ steps.pr-info.outputs.author }}
            - Branch: ${{ steps.pr-info.outputs.branch }} into ${{ steps.pr-info.outputs.base }}
            - Size: ${{ steps.pr-info.outputs.size }} (${{ steps.pr-info.outputs.additions }} additions, ${{ steps.pr-info.outputs.deletions }} deletions)
            - Files changed: ${{ steps.pr-info.outputs.files_changed }}
            - Files: ${{ steps.pr-info.outputs.file_names }}
            - Description: ${{ steps.pr-info.outputs.body }}

            Rules:
            - Keep it concise and friendly
            - Mention what the PR is about based on the title and files
            - Suggest how long the review might take based on size
            - Do NOT use emojis
            - Do NOT include the PR link (it will be added separately)
            - Do NOT use markdown formatting
            - Write in plain text only`;

            const aiMessage = await callGemini(prompt);

            if (aiMessage) {
              console.log('AI generated message:', aiMessage);
              core.setOutput('message', aiMessage);
              core.setOutput('has_ai', 'true');
            } else {
              const fallback = 'A new pull request has been opened and is ready for review.';
              console.log('Using fallback message');
              core.setOutput('message', fallback);
              core.setOutput('has_ai', 'false');
            }

      - name: Send Slack Notification
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Pull Request — Review Requested",
                    "emoji": false
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*<${{ steps.pr-info.outputs.url }}|#${{ steps.pr-info.outputs.pr_number }}: ${{ steps.pr-info.outputs.title }}>*"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ steps.ai-message.outputs.message }}"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Author:*\n${{ steps.pr-info.outputs.author_mention }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Reviewers:*\n${{ steps.pr-info.outputs.reviewer_mentions }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n`${{ steps.pr-info.outputs.branch }}` into `${{ steps.pr-info.outputs.base }}`"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Size:*\n${{ steps.pr-info.outputs.size }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Files Changed:*\n${{ steps.pr-info.outputs.files_changed }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Lines Changed:*\n+${{ steps.pr-info.outputs.additions }} / -${{ steps.pr-info.outputs.deletions }}"
                    }
                  ]
                },
                {
                  "type": "divider"
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "Severity: *LOW* | Reminders will follow if review remains pending"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "Review PR",
                        "emoji": false
                      },
                      "url": "${{ steps.pr-info.outputs.url }}/files",
                      "style": "primary"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Discussion",
                        "emoji": false
                      },
                      "url": "${{ steps.pr-info.outputs.url }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `**Slack Notification Sent**\n\n` +
                    `A review request has been posted to Slack.\n\n` +
                    `**Escalation Timeline (Demo Mode):**\n` +
                    `- 0–15 min: Channel notification (LOW)\n` +
                    `- 15–30 min: MEDIUM severity\n` +
                    `- 30–45 min: HIGH severity\n` +
                    `- 45+ min: CRITICAL severity\n`
            });