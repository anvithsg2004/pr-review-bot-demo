name: PR Review Reminder and Escalation

on:
  schedule:
    - cron: '*/15 * * * *'

  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run — only log, do not send Slack messages'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  check-pending-reviews:
    name: Check Pending PR Reviews
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Find Pending PRs and Calculate Severity
        id: pending-prs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            const config = JSON.parse(
              fs.readFileSync('.github/config/team-config.json', 'utf8')
            );

            // ========================================
            // FETCH OPEN PRs
            // ========================================
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'created',
              direction: 'asc'
            });

            console.log(`Found ${pullRequests.length} open PRs`);

            const pendingPRs = [];

            for (const pr of pullRequests) {
              console.log(`\nChecking PR #${pr.number}: ${pr.title}`);

              if (pr.draft) {
                console.log(`  Skipping: draft`);
                continue;
              }

              const skipLabels = ['no-reminder', 'wip', 'on-hold'];
              if (pr.labels.some(l => skipLabels.includes(l.name))) {
                console.log(`  Skipping: has opt-out label`);
                continue;
              }

              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const reviewsByOthers = reviews.filter(
                r => r.user.login !== pr.user.login
              );

              if (reviewsByOthers.length > 0) {
                console.log(`  Skipping: has ${reviewsByOthers.length} review(s)`);
                continue;
              }

              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number
              });

              const commentsByOthers = comments.filter(
                c => c.user.login !== pr.user.login &&
                     c.user.type !== 'Bot' &&
                     !c.body.includes('Slack Notification Sent')
              );

              if (commentsByOthers.length > 0) {
                console.log(`  Skipping: has ${commentsByOthers.length} comment(s)`);
                continue;
              }

              const { data: reviewComments } = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const reviewCommentsByOthers = reviewComments.filter(
                c => c.user.login !== pr.user.login
              );

              if (reviewCommentsByOthers.length > 0) {
                console.log(`  Skipping: has ${reviewCommentsByOthers.length} inline comment(s)`);
                continue;
              }

              console.log(`  PR is completely ignored`);

              // ========================================
              // GATHER DETAILED PR INFO
              // ========================================
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const additions = files.reduce((sum, f) => sum + f.additions, 0);
              const deletions = files.reduce((sum, f) => sum + f.deletions, 0);
              const totalChanges = additions + deletions;

              let size = 'Small';
              if (totalChanges > 500) size = 'Large';
              else if (totalChanges > 200) size = 'Medium';

              const fileNames = files.map(f => f.filename).join(', ');

              const createdAt = new Date(pr.created_at);
              const now = new Date();
              const minutesElapsed = (now - createdAt) / (1000 * 60);
              const hoursElapsed = minutesElapsed / 60;

              // Human-readable time
              let timeString = '';
              if (minutesElapsed < 60) {
                timeString = Math.round(minutesElapsed) + ' minutes';
              } else if (hoursElapsed < 24) {
                const h = Math.floor(hoursElapsed);
                const m = Math.round(minutesElapsed % 60);
                timeString = h + ' hour' + (h > 1 ? 's' : '') + (m > 0 ? ' and ' + m + ' minutes' : '');
              } else {
                const days = Math.floor(hoursElapsed / 24);
                const remainingHours = Math.round(hoursElapsed % 24);
                timeString = days + ' day' + (days > 1 ? 's' : '') + (remainingHours > 0 ? ' and ' + remainingHours + ' hour' + (remainingHours > 1 ? 's' : '') : '');
              }

              const createdFormatted = createdAt.toUTCString();

              console.log(`  Minutes elapsed: ${Math.round(minutesElapsed)}`);
              console.log(`  Time string: ${timeString}`);
              console.log(`  Size: ${size}`);
              console.log(`  Files: ${fileNames}`);

              let severity = 'low';
              const thresholds = config.escalation_thresholds;
              if (minutesElapsed >= thresholds.critical.minutes) {
                severity = 'critical';
              } else if (minutesElapsed >= thresholds.high.minutes) {
                severity = 'high';
              } else if (minutesElapsed >= thresholds.medium.minutes) {
                severity = 'medium';
              }

              console.log(`  Severity: ${severity}`);

              function getSlackMention(githubUsername) {
                const member = config.team_members[githubUsername];
                return member ? `<@${member.slack_id}>` : `@${githubUsername}`;
              }

              const authorMention = getSlackMention(pr.user.login);

              const reviewerMentions = pr.requested_reviewers.map(r => {
                return getSlackMention(r.login);
              }).join(', ') || 'No reviewers assigned';

              // ========================================
              // SMART MESSAGE GENERATOR (NO AI NEEDED)
              // ========================================

              // Different openers based on what the PR does
              const fileDescriptions = [];
              for (const f of files) {
                const name = f.filename;
                if (name.endsWith('.js')) fileDescriptions.push('JavaScript module ' + name);
                else if (name.endsWith('.ts')) fileDescriptions.push('TypeScript file ' + name);
                else if (name.endsWith('.yml') || name.endsWith('.yaml')) fileDescriptions.push('workflow configuration ' + name);
                else if (name.endsWith('.json')) fileDescriptions.push('configuration file ' + name);
                else if (name.endsWith('.md')) fileDescriptions.push('documentation ' + name);
                else if (name.endsWith('.css') || name.endsWith('.scss')) fileDescriptions.push('stylesheet ' + name);
                else if (name.endsWith('.html')) fileDescriptions.push('template ' + name);
                else fileDescriptions.push('file ' + name);
              }
              const filesDesc = fileDescriptions.join(' and ');

              // Severity-specific urgency phrases
              const urgencyPhrases = {
                low: [
                  'A quick review would be much appreciated whenever someone has a moment.',
                  'If you have a few spare minutes, this could use a pair of fresh eyes.',
                  'It would be great if someone could take a look when they get a chance.',
                  'This should be a quick one to review if anyone can pick it up.',
                  'Whenever you find some time, this PR could use your attention.'
                ],
                medium: [
                  'The review delay is starting to add up, so it would be helpful to get this looked at soon.',
                  'This has been waiting longer than usual. Could someone please prioritize a review?',
                  'We are past the typical review window now. It would be great to get some feedback moving.',
                  'The clock is ticking on this one. A timely review would really help keep things on track.',
                  'This PR has been in the queue for a while now. Please consider reviewing it today.'
                ],
                high: [
                  'This is blocking progress and needs immediate reviewer attention. Please prioritize this.',
                  'The lack of review is now holding up work. This needs to be addressed as soon as possible.',
                  'This PR has been waiting far too long without any feedback. It is becoming a bottleneck.',
                  'We need someone to step up and review this urgently. The author cannot move forward without it.',
                  'This delay is impacting the team workflow. Please review this at your earliest opportunity today.'
                ],
                critical: [
                  'This has been ignored for an unacceptable amount of time and must be reviewed immediately.',
                  'We are well past the critical threshold. This PR requires urgent attention right now.',
                  'This has been completely unattended and is severely blocking progress. Immediate action is needed.',
                  'This PR has reached critical status. All other work should be deprioritized until this is reviewed.',
                  'The review for this PR is critically overdue. Someone must pick this up without further delay.'
                ]
              };

              // Get the real name from config, fallback to GitHub username
              const configName = config.team_members[pr.user.login] ? config.team_members[pr.user.login].name : pr.user.login;
              // Create the Slack markdown hyperlink: <url|Name>
              const authorLink = `<https://github.com/${pr.user.login}|${configName}>`;

              // Opening sentence variations
              const openings = [
                `${authorLink} submitted a ${size.toLowerCase()} change to ${filesDesc} that adds ${additions} lines and removes ${deletions} lines.`,
                `A pull request updating ${filesDesc} with ${additions} additions and ${deletions} deletions was opened by ${authorLink}.`,
                `This ${size.toLowerCase()} PR by ${authorLink} introduces changes to ${filesDesc}, adding ${additions} lines across ${files.length} file(s).`,
                `${authorLink} has a ${size.toLowerCase()} PR open that modifies ${filesDesc} with ${additions} new lines of code.`,
                `Changes to ${filesDesc} totaling ${additions} additions and ${deletions} deletions are waiting for review from ${authorLink}.`
              ];

              // Time sentence variations
              const timeSentences = [
                `It has been open for ${timeString} since ${createdFormatted}, and no one has reviewed, commented, or acknowledged it.`,
                `This PR was created on ${createdFormatted} and has been sitting unreviewed for ${timeString} with zero activity.`,
                `Since being opened ${timeString} ago on ${createdFormatted}, this PR has received absolutely no attention.`,
                `For the past ${timeString}, since ${createdFormatted}, this change has had no reviews, no comments, and no engagement.`,
                `It has now been ${timeString} since this was submitted on ${createdFormatted}, and not a single person has looked at it.`
              ];

              // Pick random variants
              const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

              const statusMessage = [
                pick(openings),
                pick(timeSentences),
                pick(urgencyPhrases[severity])
              ].join(' ');

              console.log('  Message: ' + statusMessage);

              pendingPRs.push({
                number: pr.number,
                title: pr.title,
                url: pr.html_url,
                author: pr.user.login,
                author_mention: authorMention,
                reviewer_mentions: reviewerMentions,
                branch_from: pr.head.ref,
                branch_to: pr.base.ref,
                minutes_elapsed: Math.round(minutesElapsed),
                hours_elapsed: Math.round(hoursElapsed * 10) / 10,
                time_string: timeString,
                created_at: createdFormatted,
                severity: severity,
                severity_label: severity.toUpperCase(),
                size: size,
                status_message: statusMessage,
                additions: additions,
                deletions: deletions,
                changed_files: files.length,
                file_names: fileNames
              });
            }

            console.log(`\nTotal ignored PRs: ${pendingPRs.length}`);
            core.setOutput('pending_prs', JSON.stringify(pendingPRs));
            core.setOutput('should_notify', (pendingPRs.length > 0).toString());
            core.setOutput('count', pendingPRs.length);

      - name: Send Reminder to Slack
        if: steps.pending-prs.outputs.should_notify == 'true'
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
        with:
          script: |
            const pendingPRs = JSON.parse(
              `${{ steps.pending-prs.outputs.pending_prs }}`
            );

            const blocks = [
              {
                type: "header",
                text: {
                  type: "plain_text",
                  text: `PR Review Reminder — ${pendingPRs.length} PR(s) Awaiting Review`,
                  emoji: false
                }
              },
              {
                type: "context",
                elements: [{
                  type: "mrkdwn",
                  text: `${new Date().toUTCString()}`
                }]
              },
              { type: "divider" }
            ];

            for (const pr of pendingPRs) {

              const severityBar = {
                low: ':white_circle:',
                medium: ':large_yellow_circle:',
                high: ':large_orange_circle:',
                critical: ':red_circle:'
              };
              const indicator = severityBar[pr.severity] || ':white_circle:';

              blocks.push({
                type: "section",
                text: {
                  type: "mrkdwn",
                  text: `${indicator} *[${pr.severity_label}]* *<${pr.url}|#${pr.number}: ${pr.title}>*`
                }
              });

              blocks.push({
                type: "section",
                text: {
                  type: "mrkdwn",
                  text: pr.status_message
                }
              });

              blocks.push({
                type: "section",
                fields: [
                  { type: "mrkdwn", text: `*Author:*\n${pr.author_mention}` },
                  { type: "mrkdwn", text: `*Reviewers:*\n${pr.reviewer_mentions}` },
                  { type: "mrkdwn", text: `*Open Since:*\n${pr.created_at}` },
                  { type: "mrkdwn", text: `*Waiting For:*\n${pr.time_string}` },
                  { type: "mrkdwn", text: `*Branch:*\n\`${pr.branch_from}\` into \`${pr.branch_to}\`` },
                  { type: "mrkdwn", text: `*Size:*\n${pr.size} (+${pr.additions}/-${pr.deletions} | ${pr.changed_files} files)` }
                ]
              });

              const truncatedFiles = pr.file_names.length > 200
                ? pr.file_names.substring(0, 200) + '...'
                : pr.file_names;

              blocks.push({
                type: "context",
                elements: [{
                  type: "mrkdwn",
                  text: `Files: \`${truncatedFiles}\``
                }]
              });

              blocks.push({
                type: "actions",
                elements: [
                  {
                    type: "button",
                    text: {
                      type: "plain_text",
                      text: "Review Now",
                      emoji: false
                    },
                    url: `${pr.url}/files`,
                    style: ['high', 'critical'].includes(pr.severity) ? "danger" : "primary"
                  },
                  {
                    type: "button",
                    text: {
                      type: "plain_text",
                      text: "View PR",
                      emoji: false
                    },
                    url: pr.url
                  }
                ]
              });

              blocks.push({ type: "divider" });
            }

            const summary = {
              critical: pendingPRs.filter(p => p.severity === 'critical').length,
              high: pendingPRs.filter(p => p.severity === 'high').length,
              medium: pendingPRs.filter(p => p.severity === 'medium').length,
              low: pendingPRs.filter(p => p.severity === 'low').length
            };

            blocks.push({
              type: "context",
              elements: [{
                type: "mrkdwn",
                text: `:red_circle: Critical: ${summary.critical} | :large_orange_circle: High: ${summary.high} | :large_yellow_circle: Medium: ${summary.medium} | :white_circle: Low: ${summary.low}`
              }]
            });

            const payload = { blocks };

            if (process.env.DRY_RUN === 'true') {
              console.log('DRY RUN — Message preview:');
              console.log(JSON.stringify(payload, null, 2));
              return;
            }

            const https = require('https');
            const webhookUrl = new URL(process.env.SLACK_WEBHOOK_URL);

            const result = await new Promise((resolve, reject) => {
              const req = https.request({
                hostname: webhookUrl.hostname,
                path: webhookUrl.pathname,
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
              });
              req.on('error', reject);
              req.write(JSON.stringify(payload));
              req.end();
            });

            console.log(`Slack response: ${result}`);

      - name: Update PR Labels
        if: steps.pending-prs.outputs.should_notify == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pendingPRs = JSON.parse(
              `${{ steps.pending-prs.outputs.pending_prs }}`
            );

            const allSeverityLabels = [
              'review-severity:low',
              'review-severity:medium',
              'review-severity:high',
              'review-severity:critical'
            ];

            for (const pr of pendingPRs) {
              const newLabel = `review-severity:${pr.severity}`;

              for (const label of allSeverityLabels) {
                if (label !== newLabel) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      name: label
                    });
                  } catch (e) {}
                }
              }

              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: [newLabel]
                });
                console.log(`PR #${pr.number} labeled ${newLabel}`);
              } catch (e) {
                console.log(`Could not add label: ${e.message}`);
              }
            }