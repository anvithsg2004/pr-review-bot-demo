name: PR Review Reminder and Escalation

on:
  schedule:
    - cron: '*/15 * * * *'

  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run — only log, do not send Slack messages'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  check-pending-reviews:
    name: Check Pending PR Reviews
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Find Pending PRs and Calculate Severity
        id: pending-prs
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const https = require('https');

            const config = JSON.parse(
              fs.readFileSync('.github/config/team-config.json', 'utf8')
            );

            // ========================================
            // GEMINI API HELPER
            // ========================================
            async function callGemini(prompt) {
              const apiKey = process.env.GEMINI_API_KEY;
              if (!apiKey) return null;

              const url = `/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

              const requestBody = JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                  temperature: 0.8,
                  maxOutputTokens: 150
                }
              });

              return new Promise((resolve) => {
                const req = https.request({
                  hostname: 'generativelanguage.googleapis.com',
                  path: url,
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' }
                }, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const parsed = JSON.parse(data);
                      if (parsed.candidates && parsed.candidates[0]) {
                        resolve(parsed.candidates[0].content.parts[0].text.trim());
                      } else {
                        resolve(null);
                      }
                    } catch (e) {
                      resolve(null);
                    }
                  });
                });
                req.on('error', () => resolve(null));
                req.write(requestBody);
                req.end();
              });
            }

            // ========================================
            // FETCH OPEN PRs
            // ========================================
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'created',
              direction: 'asc'
            });

            console.log(`Found ${pullRequests.length} open PRs`);

            const pendingPRs = [];

            for (const pr of pullRequests) {
              console.log(`\nChecking PR #${pr.number}: ${pr.title}`);

              if (pr.draft) {
                console.log(`  Skipping: draft`);
                continue;
              }

              const skipLabels = ['no-reminder', 'wip', 'on-hold'];
              if (pr.labels.some(l => skipLabels.includes(l.name))) {
                console.log(`  Skipping: has opt-out label`);
                continue;
              }

              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const reviewsByOthers = reviews.filter(
                r => r.user.login !== pr.user.login
              );

              if (reviewsByOthers.length > 0) {
                console.log(`  Skipping: has ${reviewsByOthers.length} review(s)`);
                continue;
              }

              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number
              });

              const commentsByOthers = comments.filter(
                c => c.user.login !== pr.user.login &&
                     c.user.type !== 'Bot' &&
                     !c.body.includes('Slack Notification Sent')
              );

              if (commentsByOthers.length > 0) {
                console.log(`  Skipping: has ${commentsByOthers.length} comment(s)`);
                continue;
              }

              const { data: reviewComments } = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const reviewCommentsByOthers = reviewComments.filter(
                c => c.user.login !== pr.user.login
              );

              if (reviewCommentsByOthers.length > 0) {
                console.log(`  Skipping: has ${reviewCommentsByOthers.length} inline comment(s)`);
                continue;
              }

              console.log(`  PR is completely ignored`);

              const createdAt = new Date(pr.created_at);
              const now = new Date();
              const minutesElapsed = (now - createdAt) / (1000 * 60);
              const hoursElapsed = minutesElapsed / 60;

              console.log(`  Minutes elapsed: ${Math.round(minutesElapsed)}`);

              let severity = 'low';
              const thresholds = config.escalation_thresholds;
              if (minutesElapsed >= thresholds.critical.minutes) {
                severity = 'critical';
              } else if (minutesElapsed >= thresholds.high.minutes) {
                severity = 'high';
              } else if (minutesElapsed >= thresholds.medium.minutes) {
                severity = 'medium';
              }

              console.log(`  Severity: ${severity}`);

              function getSlackMention(githubUsername) {
                const member = config.team_members[githubUsername];
                return member ? `<@${member.slack_id}>` : `@${githubUsername}`;
              }

              const authorMention = getSlackMention(pr.user.login);

              // ========================================
              // GENERATE AI MESSAGE
              // ========================================
              const prompt = `You are a Slack bot reminding a software team to review a pull request that has been ignored. Generate a short reminder message (2-3 sentences).

              Context:
              - PR title: "${pr.title}"
              - Author: ${pr.user.login}
              - Pending for: ${Math.round(minutesElapsed)} minutes
              - Severity: ${severity.toUpperCase()}
              - Files changed: ${pr.changed_files || 0}
              - Lines: +${pr.additions || 0}/-${pr.deletions || 0}
              - No one has reviewed, commented, or even looked at this PR

              Rules:
              - Severity LOW: gentle, friendly nudge
              - Severity MEDIUM: slightly more urgent, mention the time
              - Severity HIGH: firm but professional, emphasize this is blocking work
              - Severity CRITICAL: urgent tone, this has been waiting way too long
              - Do NOT use emojis
              - Do NOT include PR links
              - Do NOT use markdown
              - Keep it plain text, 2-3 sentences max
              - Be creative, vary your messages, don't be repetitive`;

              console.log('  Calling Gemini API...');
              const aiMessage = await callGemini(prompt);

              let statusMessage = '';
              if (aiMessage) {
                console.log(`  AI message: ${aiMessage}`);
                statusMessage = aiMessage;
              } else {
                console.log('  AI unavailable, using fallback');
                const hasReviewers = pr.requested_reviewers.length > 0;
                if (hasReviewers) {
                  const reviewerMentions = pr.requested_reviewers.map(
                    r => getSlackMention(r.login)
                  );
                  statusMessage = `Waiting for review from: ${reviewerMentions.join(', ')} — no activity yet`;
                } else {
                  statusMessage = 'No reviewers assigned and no activity. Someone should pick this up.';
                }
              }

              pendingPRs.push({
                number: pr.number,
                title: pr.title,
                url: pr.html_url,
                author: pr.user.login,
                author_mention: authorMention,
                minutes_elapsed: Math.round(minutesElapsed),
                hours_elapsed: Math.round(hoursElapsed * 10) / 10,
                severity: severity,
                severity_label: severity.toUpperCase(),
                status_message: statusMessage,
                additions: pr.additions || 0,
                deletions: pr.deletions || 0,
                changed_files: pr.changed_files || 0
              });
            }

            console.log(`\nTotal ignored PRs: ${pendingPRs.length}`);
            core.setOutput('pending_prs', JSON.stringify(pendingPRs));
            core.setOutput('should_notify', (pendingPRs.length > 0).toString());
            core.setOutput('count', pendingPRs.length);

      - name: Send Reminder to Slack
        if: steps.pending-prs.outputs.should_notify == 'true'
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
        with:
          script: |
            const pendingPRs = JSON.parse(
              `${{ steps.pending-prs.outputs.pending_prs }}`
            );

            const blocks = [
              {
                type: "header",
                text: {
                  type: "plain_text",
                  text: `PR Review Reminder — ${pendingPRs.length} PR(s) with No Activity`,
                  emoji: false
                }
              },
              {
                type: "context",
                elements: [{
                  type: "mrkdwn",
                  text: `${new Date().toUTCString()}`
                }]
              },
              { type: "divider" }
            ];

            for (const pr of pendingPRs) {
              blocks.push({
                type: "section",
                text: {
                  type: "mrkdwn",
                  text: `[${pr.severity_label}] *<${pr.url}|#${pr.number}: ${pr.title}>*\n` +
                        `Author: ${pr.author_mention}\n` +
                        `Pending: *${pr.minutes_elapsed} min* (${pr.hours_elapsed}h) | ` +
                        `+${pr.additions}/-${pr.deletions} | ${pr.changed_files} files`
                },
                accessory: {
                  type: "button",
                  text: {
                    type: "plain_text",
                    text: "Review Now",
                    emoji: false
                  },
                  url: `${pr.url}/files`,
                  style: ['high', 'critical'].includes(pr.severity) ? "danger" : "primary"
                }
              });

              // AI generated message as a separate block
              blocks.push({
                type: "context",
                elements: [{
                  type: "mrkdwn",
                  text: `_${pr.status_message}_`
                }]
              });

              blocks.push({ type: "divider" });
            }

            const summary = {
              critical: pendingPRs.filter(p => p.severity === 'critical').length,
              high: pendingPRs.filter(p => p.severity === 'high').length,
              medium: pendingPRs.filter(p => p.severity === 'medium').length,
              low: pendingPRs.filter(p => p.severity === 'low').length
            };

            blocks.push({
              type: "context",
              elements: [{
                type: "mrkdwn",
                text: `Summary — Critical: ${summary.critical} | High: ${summary.high} | Medium: ${summary.medium} | Low: ${summary.low}`
              }]
            });

            const payload = { blocks };

            if (process.env.DRY_RUN === 'true') {
              console.log('DRY RUN — Message preview:');
              console.log(JSON.stringify(payload, null, 2));
              return;
            }

            const https = require('https');
            const webhookUrl = new URL(process.env.SLACK_WEBHOOK_URL);

            const result = await new Promise((resolve, reject) => {
              const req = https.request({
                hostname: webhookUrl.hostname,
                path: webhookUrl.pathname,
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
              });
              req.on('error', reject);
              req.write(JSON.stringify(payload));
              req.end();
            });

            console.log(`Slack response: ${result}`);

      - name: Update PR Labels
        if: steps.pending-prs.outputs.should_notify == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pendingPRs = JSON.parse(
              `${{ steps.pending-prs.outputs.pending_prs }}`
            );

            const allSeverityLabels = [
              'review-severity:low',
              'review-severity:medium',
              'review-severity:high',
              'review-severity:critical'
            ];

            for (const pr of pendingPRs) {
              const newLabel = `review-severity:${pr.severity}`;

              for (const label of allSeverityLabels) {
                if (label !== newLabel) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      name: label
                    });
                  } catch (e) {}
                }
              }

              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: [newLabel]
                });
                console.log(`PR #${pr.number} labeled ${newLabel}`);
              } catch (e) {
                console.log(`Could not add label: ${e.message}`);
              }
            }