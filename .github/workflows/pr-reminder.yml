name: PR Review Reminder and Escalation

on:
  schedule:
    - cron: '*/15 * * * *'

  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run — only log, do not send Slack messages'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  check-pending-reviews:
    name: Check Pending PR Reviews
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Find Pending PRs and Calculate Severity
        id: pending-prs
        uses: actions/github-script@v7
        env:
          OAUTH_LLM_CLIENT_ID: ${{ secrets.OAUTH_LLM_CLIENT_ID }}
          OAUTH_LLM_CLIENT_SECRET: ${{ secrets.OAUTH_LLM_CLIENT_SECRET }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const https = require('https');

            const config = JSON.parse(
              fs.readFileSync('.github/config/team-config.json', 'utf8')
            );

            // ========================================
            // OAUTH TOKEN HELPER — GET FRESH TOKEN
            // ========================================
            async function getAccessToken() {
              const tokenUrl = new URL(
                'https://guidewire-hub.oktapreview.com/oauth2/ausj9ftnbxOqfGU4U0h7/v1/token'
              );

              const params = new URLSearchParams({
                grant_type: 'client_credentials',
                client_id: process.env.OAUTH_LLM_CLIENT_ID,
                client_secret: process.env.OAUTH_LLM_CLIENT_SECRET,
                scope: 'any.tenant any.project scp.analytics.genai.user'
              });

              return new Promise((resolve) => {
                const req = https.request({
                  hostname: tokenUrl.hostname,
                  path: tokenUrl.pathname,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Accept': 'application/json'
                  }
                }, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const parsed = JSON.parse(data);
                      if (parsed.access_token) {
                        console.log('Token obtained, expires in:', parsed.expires_in, 'seconds');
                        resolve(parsed.access_token);
                      } else {
                        console.log('Token error:', JSON.stringify(parsed));
                        resolve(null);
                      }
                    } catch (e) {
                      console.log('Token parse error:', e.message);
                      resolve(null);
                    }
                  });
                });
                req.on('error', (e) => {
                  console.log('Token request error:', e.message);
                  resolve(null);
                });
                req.write(params.toString());
                req.end();
              });
            }

            // ========================================
            // AI CONNECT API HELPER
            // ========================================
            let cachedToken = null;

            async function callAI(prompt) {
              if (!cachedToken) {
                cachedToken = await getAccessToken();
              }
              if (!cachedToken) return null;

              const requestBody = JSON.stringify({
                model: "gpt-4o",
                messages: [
                  {
                    role: "user",
                    content: prompt
                  }
                ],
                temperature: 0.8,
                max_tokens: 300
              });

              return new Promise((resolve) => {
                const req = https.request({
                  hostname: 'aiconnect.int.ccs.guidewire.net',
                  path: '/genai/v1/chat/completions',
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Authorization': `Bearer ${cachedToken}`,
                    'x-tenant': 'guidewire',
                    'x-star': 'guidewire'
                  }
                }, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const parsed = JSON.parse(data);
                      if (parsed.choices &&
                          parsed.choices[0] &&
                          parsed.choices[0].message &&
                          parsed.choices[0].message.content) {
                        resolve(parsed.choices[0].message.content.trim());
                      } else {
                        console.log('AI response issue:', JSON.stringify(parsed).substring(0, 300));
                        resolve(null);
                      }
                    } catch (e) {
                      resolve(null);
                    }
                  });
                });
                req.on('error', () => resolve(null));
                req.write(requestBody);
                req.end();
              });
            }

            // ========================================
            // FETCH OPEN PRs
            // ========================================
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'created',
              direction: 'asc'
            });

            console.log(`Found ${pullRequests.length} open PRs`);

            const pendingPRs = [];

            for (const pr of pullRequests) {
              console.log(`\nChecking PR #${pr.number}: ${pr.title}`);

              if (pr.draft) {
                console.log(`  Skipping: draft`);
                continue;
              }

              const skipLabels = ['no-reminder', 'wip', 'on-hold'];
              if (pr.labels.some(l => skipLabels.includes(l.name))) {
                console.log(`  Skipping: has opt-out label`);
                continue;
              }

              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const reviewsByOthers = reviews.filter(
                r => r.user.login !== pr.user.login
              );

              if (reviewsByOthers.length > 0) {
                console.log(`  Skipping: has ${reviewsByOthers.length} review(s)`);
                continue;
              }

              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number
              });

              const commentsByOthers = comments.filter(
                c => c.user.login !== pr.user.login &&
                     c.user.type !== 'Bot' &&
                     !c.body.includes('Slack Notification Sent')
              );

              if (commentsByOthers.length > 0) {
                console.log(`  Skipping: has ${commentsByOthers.length} comment(s)`);
                continue;
              }

              const { data: reviewComments } = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const reviewCommentsByOthers = reviewComments.filter(
                c => c.user.login !== pr.user.login
              );

              if (reviewCommentsByOthers.length > 0) {
                console.log(`  Skipping: has ${reviewCommentsByOthers.length} inline comment(s)`);
                continue;
              }

              console.log(`  PR is completely ignored`);

              // ========================================
              // GATHER DETAILED PR INFO (NEW)
              // ========================================
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const additions = files.reduce((sum, f) => sum + f.additions, 0);
              const deletions = files.reduce((sum, f) => sum + f.deletions, 0);
              const totalChanges = additions + deletions;

              let size = 'Small';
              if (totalChanges > 500) size = 'Large';
              else if (totalChanges > 200) size = 'Medium';

              const fileNames = files.map(f => f.filename).join(', ');

              const cleanBody = (pr.body || 'No description provided')
                .substring(0, 300)
                .replace(/`/g, '')
                .replace(/\n/g, ' ')
                .replace(/\r/g, '')
                .replace(/#/g, '')
                .replace(/\*/g, '')
                .trim();

              const createdAt = new Date(pr.created_at);
              const now = new Date();
              const minutesElapsed = (now - createdAt) / (1000 * 60);
              const hoursElapsed = minutesElapsed / 60;

              // Human-readable time
              let timeString = '';
              if (minutesElapsed < 60) {
                timeString = Math.round(minutesElapsed) + ' minutes';
              } else if (hoursElapsed < 24) {
                const h = Math.floor(hoursElapsed);
                const m = Math.round(minutesElapsed % 60);
                timeString = h + ' hour' + (h > 1 ? 's' : '') + (m > 0 ? ' and ' + m + ' minutes' : '');
              } else {
                const days = Math.floor(hoursElapsed / 24);
                const remainingHours = Math.round(hoursElapsed % 24);
                timeString = days + ' day' + (days > 1 ? 's' : '') + (remainingHours > 0 ? ' and ' + remainingHours + ' hour' + (remainingHours > 1 ? 's' : '') : '');
              }

              // Created at formatted
              const createdFormatted = createdAt.toUTCString();

              console.log(`  Minutes elapsed: ${Math.round(minutesElapsed)}`);
              console.log(`  Time string: ${timeString}`);
              console.log(`  Size: ${size}`);
              console.log(`  Files: ${fileNames}`);

              let severity = 'low';
              const thresholds = config.escalation_thresholds;
              if (minutesElapsed >= thresholds.critical.minutes) {
                severity = 'critical';
              } else if (minutesElapsed >= thresholds.high.minutes) {
                severity = 'high';
              } else if (minutesElapsed >= thresholds.medium.minutes) {
                severity = 'medium';
              }

              console.log(`  Severity: ${severity}`);

              function getSlackMention(githubUsername) {
                const member = config.team_members[githubUsername];
                return member ? `<@${member.slack_id}>` : `@${githubUsername}`;
              }

              const authorMention = getSlackMention(pr.user.login);

              const reviewerMentions = pr.requested_reviewers.map(r => {
                return getSlackMention(r.login);
              }).join(', ') || 'No reviewers assigned';

              // ========================================
              // GENERATE AI MESSAGE (ENHANCED PROMPT)
              // ========================================
              const promptParts = [
                'You are a Slack bot reminding a software team to review a pull request that has been completely ignored.',
                'Generate a reminder message with exactly 3 to 4 sentences.',
                '',
                'Pull Request Details:',
                '- PR title: ' + pr.title,
                '- Author: ' + pr.user.login,
                '- Branch: ' + pr.head.ref + ' merging into ' + pr.base.ref,
                '- Description: ' + cleanBody,
                '- Files changed: ' + files.length,
                '- File names: ' + fileNames,
                '- Size: ' + size + ' (' + additions + ' lines added, ' + deletions + ' lines deleted)',
                '- PR was created on: ' + createdFormatted,
                '- This PR has been open for: ' + timeString,
                '- Severity: ' + severity.toUpperCase(),
                '- No one has reviewed, commented, or even looked at this PR',
                '- Requested reviewers: ' + (pr.requested_reviewers.map(r => r.login).join(', ') || 'none assigned'),
                '',
                'Rules:',
                '- Sentence 1: Briefly describe WHAT this PR does based on the title, description, and file names',
                '- Sentence 2: Mention exactly how long this PR has been open (use the time provided) and when it was created',
                '- Sentence 3: Based on severity, urge the team to review',
                '- Sentence 4 (optional): If severity is HIGH or CRITICAL, mention this is blocking the author',
                '',
                'Tone based on severity:',
                '- LOW: gentle, friendly reminder',
                '- MEDIUM: slightly more urgent, express concern about the delay',
                '- HIGH: firm and professional, emphasize this is blocking work and needs immediate attention',
                '- CRITICAL: urgent and serious, this has been waiting far too long and must be addressed now',
                '',
                'Formatting rules:',
                '- Do NOT use emojis',
                '- Do NOT include PR links or URLs',
                '- Do NOT use any markdown formatting (no bold, italic, backticks, asterisks, underscores)',
                '- Plain English text only',
                '- Be creative, do not repeat the same phrasing every time',
                '- Output ONLY the message text, nothing else'
              ];

              const prompt = promptParts.join('\n');

              console.log('  Calling AI Connect (gpt-4o)...');
              const aiMessage = await callAI(prompt);

              let statusMessage = '';
              if (aiMessage) {
                statusMessage = aiMessage
                  .replace(/\*/g, '')
                  .replace(/`/g, '')
                  .replace(/_/g, ' ')
                  .replace(/~/g, '')
                  .replace(/#/g, '')
                  .replace(/\n+/g, ' ')
                  .replace(/\s+/g, ' ')
                  .trim();
                console.log('  AI message: ' + statusMessage);

                if (statusMessage.length < 50) {
                  console.log('  Too short, using fallback');
                  statusMessage = '';
                }
              } else {
                console.log('  AI returned null');
              }

              // Fallback message with full details
              if (!statusMessage) {
                statusMessage = 'This PR by ' + pr.user.login +
                  ' introduces changes to ' + fileNames +
                  '. It has been open for ' + timeString +
                  ' since ' + createdFormatted +
                  ' with zero reviews or comments. ' +
                  (severity === 'critical' || severity === 'high'
                    ? 'This needs immediate attention as it is blocking progress.'
                    : 'Please take a moment to review when you get a chance.');
                console.log('  Fallback: ' + statusMessage);
              }

              pendingPRs.push({
                number: pr.number,
                title: pr.title,
                url: pr.html_url,
                author: pr.user.login,
                author_mention: authorMention,
                reviewer_mentions: reviewerMentions,
                branch_from: pr.head.ref,
                branch_to: pr.base.ref,
                minutes_elapsed: Math.round(minutesElapsed),
                hours_elapsed: Math.round(hoursElapsed * 10) / 10,
                time_string: timeString,
                created_at: createdFormatted,
                severity: severity,
                severity_label: severity.toUpperCase(),
                size: size,
                status_message: statusMessage,
                additions: additions,
                deletions: deletions,
                changed_files: files.length,
                file_names: fileNames
              });
            }

            console.log(`\nTotal ignored PRs: ${pendingPRs.length}`);
            core.setOutput('pending_prs', JSON.stringify(pendingPRs));
            core.setOutput('should_notify', (pendingPRs.length > 0).toString());
            core.setOutput('count', pendingPRs.length);

      - name: Send Reminder to Slack
        if: steps.pending-prs.outputs.should_notify == 'true'
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
        with:
          script: |
            const pendingPRs = JSON.parse(
              `${{ steps.pending-prs.outputs.pending_prs }}`
            );

            const blocks = [
              {
                type: "header",
                text: {
                  type: "plain_text",
                  text: `PR Review Reminder — ${pendingPRs.length} PR(s) Awaiting Review`,
                  emoji: false
                }
              },
              {
                type: "context",
                elements: [{
                  type: "mrkdwn",
                  text: `${new Date().toUTCString()}`
                }]
              },
              { type: "divider" }
            ];

            for (const pr of pendingPRs) {

              // Severity indicator
              const severityBar = {
                low: ':white_circle:',
                medium: ':large_yellow_circle:',
                high: ':large_orange_circle:',
                critical: ':red_circle:'
              };
              const indicator = severityBar[pr.severity] || ':white_circle:';

              // PR title and link
              blocks.push({
                type: "section",
                text: {
                  type: "mrkdwn",
                  text: `${indicator} *[${pr.severity_label}]* *<${pr.url}|#${pr.number}: ${pr.title}>*`
                }
              });

              // AI-generated description (the rich message)
              blocks.push({
                type: "section",
                text: {
                  type: "plain_text",
                  text: pr.status_message,
                  emoji: false
                }
              });

              // Detailed info fields
              blocks.push({
                type: "section",
                fields: [
                  { type: "mrkdwn", text: `*Author:*\n${pr.author_mention}` },
                  { type: "mrkdwn", text: `*Reviewers:*\n${pr.reviewer_mentions}` },
                  { type: "mrkdwn", text: `*Open Since:*\n${pr.created_at}` },
                  { type: "mrkdwn", text: `*Waiting For:*\n${pr.time_string}` },
                  { type: "mrkdwn", text: `*Branch:*\n\`${pr.branch_from}\` into \`${pr.branch_to}\`` },
                  { type: "mrkdwn", text: `*Size:*\n${pr.size} (+${pr.additions}/-${pr.deletions} | ${pr.changed_files} files)` }
                ]
              });

              // Files changed
              const truncatedFiles = pr.file_names.length > 200
                ? pr.file_names.substring(0, 200) + '...'
                : pr.file_names;

              blocks.push({
                type: "context",
                elements: [{
                  type: "mrkdwn",
                  text: `Files: \`${truncatedFiles}\``
                }]
              });

              // Review button
              blocks.push({
                type: "actions",
                elements: [
                  {
                    type: "button",
                    text: {
                      type: "plain_text",
                      text: "Review Now",
                      emoji: false
                    },
                    url: `${pr.url}/files`,
                    style: ['high', 'critical'].includes(pr.severity) ? "danger" : "primary"
                  },
                  {
                    type: "button",
                    text: {
                      type: "plain_text",
                      text: "View PR",
                      emoji: false
                    },
                    url: pr.url
                  }
                ]
              });

              blocks.push({ type: "divider" });
            }

            // Summary footer
            const summary = {
              critical: pendingPRs.filter(p => p.severity === 'critical').length,
              high: pendingPRs.filter(p => p.severity === 'high').length,
              medium: pendingPRs.filter(p => p.severity === 'medium').length,
              low: pendingPRs.filter(p => p.severity === 'low').length
            };

            blocks.push({
              type: "context",
              elements: [{
                type: "mrkdwn",
                text: `:red_circle: Critical: ${summary.critical} | :large_orange_circle: High: ${summary.high} | :large_yellow_circle: Medium: ${summary.medium} | :white_circle: Low: ${summary.low}`
              }]
            });

            const payload = { blocks };

            if (process.env.DRY_RUN === 'true') {
              console.log('DRY RUN — Message preview:');
              console.log(JSON.stringify(payload, null, 2));
              return;
            }

            const https = require('https');
            const webhookUrl = new URL(process.env.SLACK_WEBHOOK_URL);

            const result = await new Promise((resolve, reject) => {
              const req = https.request({
                hostname: webhookUrl.hostname,
                path: webhookUrl.pathname,
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
              });
              req.on('error', reject);
              req.write(JSON.stringify(payload));
              req.end();
            });

            console.log(`Slack response: ${result}`);

      - name: Update PR Labels
        if: steps.pending-prs.outputs.should_notify == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pendingPRs = JSON.parse(
              `${{ steps.pending-prs.outputs.pending_prs }}`
            );

            const allSeverityLabels = [
              'review-severity:low',
              'review-severity:medium',
              'review-severity:high',
              'review-severity:critical'
            ];

            for (const pr of pendingPRs) {
              const newLabel = `review-severity:${pr.severity}`;

              for (const label of allSeverityLabels) {
                if (label !== newLabel) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      name: label
                    });
                  } catch (e) {}
                }
              }

              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: [newLabel]
                });
                console.log(`PR #${pr.number} labeled ${newLabel}`);
              } catch (e) {
                console.log(`Could not add label: ${e.message}`);
              }
            }